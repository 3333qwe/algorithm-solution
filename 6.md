## 6.4 Dictionary lookup

### What is the annotation of T(i,j) or T(i)
- T(i) is whether the 1~n is a valid word list.
- preview(i)=j is the last word if T(i) is valid so that we can split track T(j)(previous words) and x(j+1 to i) (last word)

We want find T(n) and preview(n) to trace back


### What is sub problem

base cases:

T(0) = true

T(i) = OR among all (T(j) AND dict(j+1,i))

where i in `[0,n]` and j in `[0,i]`

### What is algorithm
```
T(0) = 0

for i in 1..n:
  for j in 0.. i:
    if (T(j) AND dict(j+1,i) == true):
      T(i) = true
      preview(i)=j


i=n
list=[]
while i!=0:
  list.add(preview(i)) 
  i = preview(i)

reverse the list

```

### Complexity

O(n^2) + O(n)

so O(n^2)

## 6.8 Longest common substring
Note: [6.11](##6.11 Longest common subsequence)

### What is the annotation of T(i,j) or T(i)
T(i,j) = Longest common substring end with X_i, Y_j

### What is sub problem
T(i,0) = 0
T(0,j) = 0

T(i,j) = T(i-1,j-1)+1 if X_i = Y_j else 0


### What is algorithm

```

for i in 1..n:
    T(i,0) = 0

for j in 1..m:
    T(0,j) = 0

for i in 1..n:
    for j in 1..m:
        T(i,j) = T(i-1,j-1)+1 if X_i = Y_j else 0

```

### Complexity
O(mn)

## 6.11 Longest common subsequence
Note: [6.8](## 6.8)

### What is the annotation of T(i,j) or T(i)
T(i,j) = Longest common subsequnence end with X_i, Y_j

### What is sub problem
T(i,0) = 0

T(0,j) = 0

T(i,j) = T(i-1,j-1)+1 if X_i = Y_j else max(T(i-1,j), T(i,j-1))

### What is algorithm
```

for i in 1..n:
    T(i,0) = 0

for j in 1..m:
    T(0,j) = 0

for i in 1..n:
    for j in 1..m:
        if X_i = Y_j:
            T(i,j) = T(i-1,j-1)+1 
        else:
            T(i,j) = max(T(i-1,j), T(i,j-1)) 

```


### Complexity

O(mn)


## 6.18 Making change II

### What is the annotation of T(i,j) or T(i)
T[v] is the set of i that sum(x_i) = v

We want to find what T[v] is. 

### What is sub problem

```
for all x_j
T[i] = T[i-x_j] + x_j if 
1. i-x_j>=0 AND 
2. x_j not in T[i-x_j] (only once) AND 
3. i-x_j is makable, (T[i-x_j] != null)
```



### What is algorithm

```
T[0] = 0
for i = 1..v:
    T[i] = null

for i = 1..v:
    for j = 1..n:
        if i-x_j>=0 AND x_j not in T[i-x_j] AND T[i-x_j] != null:
            T[i] = T[i-x_j] + x_j
            break;

return T[v] == null
```

### Complexity

in if statement, `x_j in T[i-x_j]` can be O(1) for hashset. 
O(vn)



## 6.19 Making change k

### What is the annotation of T(i,j) or T(i)

### What is sub problem

### What is algorithm

### Complexity

## 6.20 Optimal Binary Search Tree

### What is the annotation of T(i,j) or T(i)

### What is sub problem

### What is algorithm

### Complexity


## 6.26 Alignment

### What is the annotation of T(i,j) or T(i)

### What is sub problem

### What is algorithm

### Complexity


